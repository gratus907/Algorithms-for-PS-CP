\documentclass[landscape,8pt]{article}
\linespread{1}
\usepackage{multicol}
\setlength{\columnsep}{0.5cm}
\setlength{\columnseprule}{0.25pt}
\usepackage{amsmath}
\usepackage{graphbox}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{geometry}
\geometry{a4paper, landscape, margin = 0.6in}
\usepackage{enumerate}
\usepackage{amsthm}
\usepackage{physics}
\usepackage{float}
\usepackage{kotex}
\usepackage{tabu}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{authblk}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhead[R]{Wonseok Shin}
\fancyhead[L]{SNUPC Algorithm Note}
\usepackage[compact]{titlesec}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\newcommand{\st}{\text{ such that }}
\newcommand{\for}{\text{ for }}
\newcommand{\newpara}[1]{\paragraph{#1} \mbox{}\\}
\everymath{\displaystyle}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parindent}{0pt}
\titlespacing{\section}{0pt}{*0}{*0}
\titlespacing{\subsection}{0pt}{*1}{*0.5}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\topsep=5pt \partopsep=5pt
\title{\textbf{SNUPC Jammanbo's Note}}
\author{ }
\date{ }

\begin{document}
% Original Cover page for team note.
\begin{comment}
  {
    \setlength{\columnseprule}{0pt}
    \begin{multicols}{3}\raggedcolumns
    \vspace*{\fill}
    \begin{figure}[H]
    \includegraphics[width=\linewidth]{piplup}
    \end{figure}%
    \vspace*{\fill}
    \columnbreak
    \begin{center}
    \vspace*{\fill}
    \huge{\textbf{Little Piplup}\\}
    \vspace{2em}
      \LARGE{Contest Teamnote \\}
     \large{UCPC 2019 ver}
    \vspace*{\fill}
    \end{center}
    \columnbreak

    \vspace*{\fill}
    \begin{figure}[H]
    \includegraphics[width=\linewidth]{revplup}
    \end{figure}

    \vspace*{\fill}
    \end{multicols}
  }
\end{comment}

% Personal Cover Page
  \begin{center}
    \Huge{\textbf{SNUPC Jammanbo's Note}}\\
    \vspace{0.5em}
    \Large{Gratus907 (Wonseok Shin)}
    \vspace{-1.5em}
  \end{center}
  \begin{figure}[H]
  \includegraphics[width = \linewidth]{Jammanbo.jpg}
  \end{figure}
% Document Starts from here

\newpage
\maketitle
\begin{multicols}{3}\raggedcolumns
\tableofcontents
\end{multicols}
\pagebreak
\begin{multicols}{2}\raggedcolumns
\section{Settings}
  \subsection{C++}
    O3, Ofast, avx, avx2, fma 때려넣고 기도메타도 필요하면 사용하기.
    \verbatiminput{./code/Header.cpp}
  \subsection{Other Setting}
    \begin{itemize}
      \item VSC Color Theme : One Dark Pro Monokai Darker
      \item Vimrc
      \verbatiminput{./code/vimrc}
    \end{itemize}
\section{Data Structures}
  \subsection{Segment Tree - Range Minimum}
     필요한 연산에 따라 적당히 수정해서 쓸 수 있는 SegTree 구현. 현재 range minimum을 기준으로 작성됨.\\
     배열 0-base
     \verbatiminput{./code/Data_Structures/Range_Minimum_Query.cpp}

  \subsection{Segment Tree Lazy Propagation}
     구간 업데이트 연산을 빠르게 하기 위한 Lazy Propagation이 적용된 SegTree.\\
     배열 0-base
     \verbatiminput{./code/Data_Structures/Segment_Tree_Lazy.cpp}
  \subsection{Fenwick Tree}
    \verbatiminput{./code/Data_Structures/Fenwick_Tree.cpp}
  \subsection{Disjoint Set Union (Union - Find)}
    \verbatiminput{./code/Data_Structures/Disjoint_Set_Union.cpp}
\columnbreak
\section{Mathematics}
  \subsection{Useful Mathematical Formula}
    \begin{itemize}
      \item Catalan Number : Number of valid parantheses strings with $n$ pairs
      \[
        C_n = \frac{1}{n+1}\binom{2n}{n}
      \]
      \item Nim Game : Remember - XOR of all piles.
      \item Lucas Formula : $\binom{n}{m} = \prod \binom{n_i}{m_i} \mod p$
    \end{itemize}
  \subsection{Number of Integer Partition}
    \verbatiminput{./code/Mathematics/Num_of_Integer_Partition.py}

  \subsection{Binomial Coefficient}
    Fast-to-Type Binomial coefficient, in $O(k)$ time.
    \verbatiminput{./code/Mathematics/Efficient_Binomial_Coefficient.cpp}

  \subsection{Extended Euclidean Algorithm}
    \verbatiminput{./code/Mathematics/extended_euclidean_algorithm.cpp}

  \subsection{Fast Modulo Exponentiation}
  Calculating \texttt{$x^y$ mod $p$} in $\order{\log y}$ time.
    \verbatiminput{./code/Mathematics/Fast_Modulo_Exponentiation.cpp}

  \subsection{Miller-Rabin Primality Testing}
  Base values of $a$ chosen so that results are tested to be correct up to $10^{14}$.
    \verbatiminput{./code/Mathematics/Miller_Rabin_Test.cpp}

  \subsection{Pollard-Rho Factorization}
    \verbatiminput{./code/Mathematics/Pollard_Rho_Algorithm.cpp}

  \subsection{Euler Totient}
  Calculating number of integers below $n$ which is coprime with $n$.
    \verbatiminput{./code/Mathematics/Euler_Phi_Function.cpp}

  \subsection{Modular Multiplicative Inverse}
    \verbatiminput{./code/Mathematics/Modular_Inverse.cpp}

  %\subsection{Kitamasa method}

  \subsection{Fast Fourier Transform}
    Convolution $C_i$ 를 $O(n \log n)$ 에 구한다.
    $$C_i = \sum_{j = 0}^{i} a_j b_{i-j}$$
    \verbatiminput{./code/Mathematics/Fast_Fourier_Transform.cpp}
  \subsection{Number Theoretic Transform}
    Modulo version FFT.
    \verbatiminput{./code/Mathematics/Number_Theoretic_Transform.cpp}
  \columnbreak
\columnbreak
\section{Geometry}
  \subsection{CCW}
    \verbatiminput{./code/Geometry/CCW.cpp}
  \subsection{Point in polygon}
    Returns boolean, if point is in the polygon (represented as vector of points).
    \verbatiminput{./code/Geometry/Point_in_polygon.cpp}
  \subsection{Length of Segment Union}
    Length of segment union, from vector of \{start, end\}.
    \verbatiminput{./code/Geometry/Length_of_Segment_Union.cpp}
  \subsection{Closest Pair Problem}
    Requires : Points must be sorted with x-axis.\\
    Runs in $\mathcal{O}(n \log^2 n)$
    \verbatiminput{./code/Geometry/Closest_pair.cpp}
  \subsection{Convex Hull (Graham Scan)}
    \verbatiminput{./code/Geometry/Graham_Scan.cpp}
  \subsection{Intersection of Line Segment}
    \verbatiminput{./code/Geometry/Line_Segment_Intersection.cpp}
\columnbreak

\section{Graphs}
  \subsection{Topological Sorting}
  Topological sorting with dfs
    \verbatiminput{./code/Graph/Topological_Sort.cpp}

  \subsection{Lowest Common Ancestor}
  LCA Algorithm by sparse table.
  minlen : $(x, y)$ 사이를 잇는 간선 중 최소 길이 간선. \\
  maxlen : $(x, y)$ 사이를 잇는 간선 중 최대 길이 간선.
    \verbatiminput{./code/Graph/Lowest_Common_Ancestor.cpp}

  \subsection{MST Kruskal Algorithm}
  Based on Union-Find implementation\\
  $\order{E \log E}$ if path-compressed Union Find.
    \verbatiminput{./code/Graph/Kruskal_MST.cpp}

  \subsection{MST Prim Algorithm}
    \verbatiminput{./code/Graph/Prim_MST.cpp}

  %\subsection{MST Borvuka Algorithm}

  \subsection{Dinic's Algorithm}
    \verbatiminput{./code/Graph/Dinic.cpp}

  %\subsection{Heavy-Light Decomposition}

  %\subsection{Centroid Decomposition}

  %\subsection{Hungarian Algorithm}
    %$\order{n^3}$ assignment problem
\columnbreak

\section{Shortest Path}
  \subsection{Dijkstra}
    $\order{E \log V}$ Single-Start-Shortest-Path.\\
    Not working for graph with minus weight.
      \verbatiminput{./code/Graph/Dijkstra_Algorithm.cpp}

  \subsection{Bellman Ford}
    $\order{EV}$ Single-Start-Shortest-Path.\\
    Not working for graph with minus cycle $\rightarrow$ must detect.
      \verbatiminput{./code/Graph/Bellman_Ford_Algorithm.cpp}

  \subsection{SPFA Algorithm}
    Average $\order{E}$, worst $\order{VE}$ time. Average-case improvement of Bellman Ford by using an additional queue.
      \verbatiminput{./code/Graph/SPFA.cpp}
  \subsection{Floyd-Warshall}
    Works on adjacency matrix, in $\order{V^3}$.
      \verbatiminput{./code/Graph/Floyd_Warshall_Algorithm.cpp}

\columnbreak

\section{Dynamic}
  \subsection{Longest Increasing Subsequence}
    Find LIS in $\order{n \log n}$ time.
      \verbatiminput{./code/Dynamic_Programming/Longest_Increasing_Subsequence.cpp}
    Multiset 기반으로 더 짧게 구현
      \verbatiminput{./code/Dynamic_Programming/Multiset_Shorter_LIS.cpp}

  \subsection{Largest Sum Subarray}
    Computes sum of largest sum subarray in $\order{N}$
      \verbatiminput{./code/Dynamic_Programming/Largest_Maximum_Subarray.cpp}

  \subsection{0-1 Knapsack}
    \verbatiminput{./code/Dynamic_Programming/0-1_Knapsack.cpp}

  \subsection{Longest Common Subsequence}
    \verbatiminput{./code/Dynamic_Programming/Longest_Common_Substring.cpp}

  \subsection{Edit Distance}
    \verbatiminput{./code/Dynamic_Programming/Edit_Distance.cpp}

  %\subsection{Convex Hull Trick}

  %\subsection{Divide and Conquer Optimization}

  %\subsection{Knuth Optimization}

\section{String}
  \subsection{KMP Algorithm}
    \verbatiminput{./code/String/KMP.cpp}
  \subsection{Manacher's Algorithm}
    A[i] = $i$ 번을 중심으로 하는 가장 긴 팰린드롬이 되는 반지름.
    \verbatiminput{./code/String/Manacher.cpp}
  \subsection{Trie}
    \verbatiminput{./code/String/Trie.cpp}
  \subsection{Rabin-Karp Hashing}
    Hashmap[$k$]에, 길이가 len인 부분 문자열의 해시값이 $k$ 가 되는 시작점 인덱스 $i$ 를 push.
    \verbatiminput{./code/String/Rabin-Karp.cpp}
  %\subsection{Aho-Corasick Algorithm}
\columnbreak

\section{Miscellaneous}
  \subsection{Binary and Ternary Search}
    Preventing stupid mistakes by writing garbage instead of proper binary search.\\
    Depends on problem and situation, what we want is either \texttt{lo} or \texttt{hi}.
    \verbatiminput{./code/Misc/Binary_Search.cpp}
    Ternary search
    \verbatiminput{./code/Misc/Ternary_search.cpp}
  \subsection{Useful Bitwise Functions in C++}
    \begin{verbatim}
      int __builtin_clz(int x);// number of leading zero
      int __builtin_ctz(int x);// number of trailing zero
      int __builtin_clzll(ll x);// number of leading zero
      int __builtin_ctzll(ll x);// number of trailing zero
      int __builtin_popcount(int x);// number of 1-bits in x
      int __builtin_popcountll(ll x);// number of 1-bits in x

      lsb(n): (n & -n); // last bit (smallest)
      floor(log2(n)): 31 - __builtin_clz(n | 1);
      floor(log2(n)): 63 - __builtin_clzll(n | 1);

      // compute next perm. ex) 00111, 01011, 01101, 01110, 10011, 10101..
      ll next_perm(ll v)
      {
        ll t = v | (v-1);
        return (t + 1) | (((~t & -~t) - 1) >> (__builtin_ctz(v) + 1));
      }
    \end{verbatim}
  \subsection{List of Useful Numbers}
    \begin{verbatim}
      < 10^k    prime   # of prime          < 10^k            prime
      -------------------------------------------------------------
      1             7            4          10           9999999967
      2            97           25          11          99999999977
      3           997          168          12         999999999989
      4          9973         1229          13        9999999999971
      5         99991         9592          14       99999999999973
      6        999983        78498          15      999999999999989
      7       9999991       664579          16     9999999999999937
      8      99999989      5761455          17    99999999999999997
      9     999999937     50847534          18   999999999999999989
    \end{verbatim}
  \subsection{Order Statistics Tree}
    $k$번째 수 쿼리를 $O(\log n)$ 에 알아서 잘 처리해 주는 마법의 자료구조. 생각보다 상수가 크니 조심해야 함. Merge Sort Tree를 짜는 거보단 나은 선택일 것 같다.
    \verbatiminput{./code/Misc/Pbds_OST.cpp}

\columnbreak


\section{Checkpoints}
  \subsection{Debugging}
    \begin{itemize}
      \item $10^5 * 10^5 \Rightarrow \text{INTEGER OVERFLOW}$. 특히 for문 안에서 $i*i$ 할 때 조심하기.
      \item If unsure with overflow, use \\
      \texttt{\#define int long long} and stop caring. 이때 \texttt{int32\_t main()}.
      \item 행렬과 기하의 $i, j$ 인덱스 조심. 헷갈리면 쓰면서 가기. 문제에 $x, y$ 좌표로 주면 그걸로 가도 좋을듯.
      \item output이 특정 수열/OX 형태 : 작은 예제를 By hand 또는 간단한 코드로 Exhasutive Search. 모르는 무언가를 알기 위해서는 데이터가 필요하다.
    \end{itemize}
  \subsection{Thinking}
    \begin{itemize}
      \item 모든 경우를 다 할 수 없나? 왜 안 되지? 시간 복잡도 잘 생각해 보기. 알고리즘 생각하기 전에 Bruteforce에서 출발하기. 정해의 Target Complexity를 먼저 생각하고 주요 알고리즘들의 Complexity로 짜맞추기.\\
      예를들어, 쿼리가 30만개 들어온다면 한 쿼리를 적어도 $\log{n}$ 에 처리할 방법이 아무튼 있다는 뜻.
      \item 단조함수이며, 충분히 빠르게 검증가능한가 : Binary Search.
      \item 특히 ``가능한 최대의 $x$" $\to$ Binary Search.
      \item 차원이 높은 문제 : 차원 내려서 생각하기. 3 $\rightarrow$ 2.
      \item 이 문제가 사실 그래프 관련 문제는 아닐까? 모델링이 가능할까?
          \begin{itemize}
            \item 만약 그렇다면, `간선' 과 `정점' 은 각각..?
            \item 간선과 정점이 몇 개 정도 있는가?
          \end{itemize}
      \item 이 문제에 Overlapping Subproblem이 보이나? \\$\rightarrow$ Dynamic Programming 을 적용.
      \item 답의 상한이 Reasonable 하게 작은가?
      \item 그래프 문제에서, 어떤 ``조건" 이 들어갔을 때 $\to$ 이 문제를 ``정점을 늘림으로써" 단순한 그래프 문제로 바꿀 수 있나? (ex : SNUPC 2018 달빛 여우) 이를테면, 홀짝성에 따라 점을 2배로 늘림으로써?
      \item DP도 마찬가지. 어떤 조건을 단순화하기 위해 상태의 수를 사이사이에 집어넣을 수 있나?
      \item Square root Decomposition : $O(n \log n)$ 이 생각나면 좋을 것 같지만 잘 생각나지 않고, 제한을 보니 $O(n \sqrt{n})$ 이면 될것도 같이 생겼을 때 생각해 보기.
      \item 마지막 생각 : 조금 추하지만 해싱이나 Random, \texttt{bitset} 을 이용한 $n^2 / 64$ 같은걸로 뚫을 수 있나?
    \end{itemize}
\newpage
\section*{업데이트 노트 / To-Do}
\textbf{이 페이지는 실제 인쇄 팀노트에 포함되지 않습니다}
\begin{itemize}
  \item 190731 : Rabin-Karp Hashing 추가.
  \item 190731 : LCA 코드에 최단 / 최장 거리 간선, 거리 구하기 추가.
  \item 190731 : Segment Tree Lazy Propagation 추가.
  \item 190731 : Segment Tree Struct 구현체로 변경. (UCPC Finalized)
  \item 190817 : SPFA Algorithm 추가.
  \item 190826 : FFT, NTT 추가.
  \item To-do : HLD 코드 넣기.
  \item To-do : Centroid Decomposition
  \item To-do : Trie 구현체 두가지 방식 넣기.
\columnbreak
\end{itemize}
\end{multicols}
\end{document}
